{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Geyser is a bridge between Minecraft: Bedrock Edition and Minecraft: Java Edition, closing the gap from those wanting to play true cross-platform. Geyser is an open collaboration project by CubeCraft Games. What is Geyser? \u00b6 Geyser is a proxy, bridging the gap between Minecraft: Bedrock Edition and Minecraft: Java Edition servers. The ultimate goal of this project is to allow Minecraft: Bedrock Edition users to join Minecraft: Java Edition servers as seamlessly as possible. Please note, this project is still a work in progress and should not be used on production. Expect bugs! Special thanks to the DragonProxy project for being a trailblazer in protocol translation and for all the team members who have now joined us here! Note Currently supporting Minecraft Bedrock v1.14.6(0) and Minecraft Java v1.15.2. Setting Up \u00b6 Take a look here for how to set up Geyser. Links: \u00b6 Website: https://geysermc.org Docs: https://github.com/GeyserMC/Geyser/wiki Download: http://ci.geysermc.org Discord: http://discord.geysermc.org/ Donate: https://patreon.com/GeyserMC Libraries Used: \u00b6 NukkitX Bedrock Protocol Library Steveice10's Java Protocol Library TerminalConsoleAppender Simple Logging Facade for Java (slf4j)","title":"Introduction"},{"location":"#what-is-geyser","text":"Geyser is a proxy, bridging the gap between Minecraft: Bedrock Edition and Minecraft: Java Edition servers. The ultimate goal of this project is to allow Minecraft: Bedrock Edition users to join Minecraft: Java Edition servers as seamlessly as possible. Please note, this project is still a work in progress and should not be used on production. Expect bugs! Special thanks to the DragonProxy project for being a trailblazer in protocol translation and for all the team members who have now joined us here! Note Currently supporting Minecraft Bedrock v1.14.6(0) and Minecraft Java v1.15.2.","title":"What is Geyser?"},{"location":"#setting-up","text":"Take a look here for how to set up Geyser.","title":"Setting Up"},{"location":"#links","text":"Website: https://geysermc.org Docs: https://github.com/GeyserMC/Geyser/wiki Download: http://ci.geysermc.org Discord: http://discord.geysermc.org/ Donate: https://patreon.com/GeyserMC","title":"Links:"},{"location":"#libraries-used","text":"NukkitX Bedrock Protocol Library Steveice10's Java Protocol Library TerminalConsoleAppender Simple Logging Facade for Java (slf4j)","title":"Libraries Used:"},{"location":"contributing/","text":"Contributing \u00b6 Here are some ways that you can help contribute to this project. New ideas or Bug Reports \u00b6 Need something? Found a bug? Or just have a brilliant idea? Head to the Issues and create a new one. Please feel free to reach out to us on Discord if you're interested in helping out with Geyser. Contributing Code \u00b6 If you know Java then take a look at open issues and create a pull request. Do the following to build the code: git clone https://github.com/GeyserMC/Geyser cd Geyser git submodule update --init --recursive mvn clean install Contributing Documentation \u00b6 If you can help improve the documentation it would be highly appreciated. Have a look under the docs folder for the existing documentation. The documentation is built using mkdocs . You can set up a hot-build dev environment that will auto-refresh changes as they are made. Requirements \u00b6 python3 pip3 npm (only if changing themes) Install dependencies by running: pip3 install -r requirements.txt Note It's recommended to use a virtualenv so that you don't pollute your system environment. Dev Environment \u00b6 To start a http document server on http://127.0.0.1:8000 execute: mkdocs serve Change PDF Theme \u00b6 Edit the PDF theme under docs/theme/pdf . Rebuild by doing the following: cd docs/theme/pdf npm install npm run build-compressed This will update pdf.css under docs/css/pdf.css . Rebuilding the docs will now use the new theme.","title":"Contributing"},{"location":"contributing/#contributing","text":"Here are some ways that you can help contribute to this project.","title":"Contributing"},{"location":"contributing/#new-ideas-or-bug-reports","text":"Need something? Found a bug? Or just have a brilliant idea? Head to the Issues and create a new one. Please feel free to reach out to us on Discord if you're interested in helping out with Geyser.","title":"New ideas or Bug Reports"},{"location":"contributing/#contributing-code","text":"If you know Java then take a look at open issues and create a pull request. Do the following to build the code: git clone https://github.com/GeyserMC/Geyser cd Geyser git submodule update --init --recursive mvn clean install","title":"Contributing Code"},{"location":"contributing/#contributing-documentation","text":"If you can help improve the documentation it would be highly appreciated. Have a look under the docs folder for the existing documentation. The documentation is built using mkdocs . You can set up a hot-build dev environment that will auto-refresh changes as they are made.","title":"Contributing Documentation"},{"location":"contributing/#requirements","text":"python3 pip3 npm (only if changing themes) Install dependencies by running: pip3 install -r requirements.txt Note It's recommended to use a virtualenv so that you don't pollute your system environment.","title":"Requirements"},{"location":"contributing/#dev-environment","text":"To start a http document server on http://127.0.0.1:8000 execute: mkdocs serve","title":"Dev Environment"},{"location":"contributing/#change-pdf-theme","text":"Edit the PDF theme under docs/theme/pdf . Rebuild by doing the following: cd docs/theme/pdf npm install npm run build-compressed This will update pdf.css under docs/css/pdf.css . Rebuilding the docs will now use the new theme.","title":"Change PDF Theme"},{"location":"events/","text":"Events \u00b6 Geyser has an Event Manager that allows one to listen to or trigger an event easily. Events can be easily defined either by defining a method to be an event handler or by providing a lambda. Each event handler will be executed in turn based upon their priority. Triggering an Event \u00b6 An event is derived from either GeyserEvent or CancellableGeyserEvent . Example public class MyCustomEvent extends GeyserEvent { } The event is triggered through the triggerEvent method of the Event Manager. Example eventManager . triggerEvent ( new MyCustomEvent ()); This returns an EventResult which can be used to chain additional commands based upon the result. They include ifNotCancelled and ifCancelled . Example eventManager . triggerEvent ( new MyCustomEvent ()) . ifNotCancelled (( result ) -> { // Code executed if events were not cancelled }); Listening to an Event \u00b6 There are two ways to listen for an event. One can either create an event handler method or one can create an anonymous lamda to be executed when the event is triggered. Class Event Handler \u00b6 An event handler method is a method that is annotated with @Event . The class it belongs to must also be registered with the event manager. Example public class MyClass { @Event public void onEnable ( EventContext ctx , MyCustomEvent event ) { System . err . println ( \"Hello World\" ); } } ... GeyserConnecter . getInstance (). getEventManager . registerEvents ( new MyClass ()); Important Plugins should use the registerEvents method inherited from GeyserPlugin . The @Event annotation has the following optional parameters: priority - Integer from 0 - 100. Default 50 . Event Handlers are executed in order from lowest to highest priority. ignoreCancelled - Boolean. Default true . If true then if an event is cancelled the handler will not be executed. The EventContext will be discussed later. MyCustomEvent is the event defined previously. Anonymous Lambda \u00b6 An event can be hooked through the on method of the EventManager provided with an anonymous function. This allows code to be placed logically close to where it is related in the code instead of having to set up a separate class and method listeners. Example GeyserConnector . getInstance (). getEventManager (). on ( MyCustomEvent . class , ( ctx , event ) -> { System . err . println ( \"Hello World\" ); }); Important Plugins should use the on method inherited from GeyserPlugin . This method takes 2 optional parameters specifying the priority of the event and if the handler should ignore cancelled events. This returns an EventRegisterResult that allows one to chain a delay on, normally to used to cancel the handler. It is safe to cancel an already cancelled handler. Example GeyserConnector . getInstance (). getEventManager (). on ( MyCustomEvent . class , ( ctx , event ) -> { System . err . println ( \"If this doesn't trigger in 10 seconds it is cancelled\" ); ctx . unregister (); }). onDelay (( ctx ) -> { ctx . unregister (); }, 10 , TimeUnit . SECONDS ); Event Context \u00b6 The event handler receives an EventContext in addition to the Event class. The EventContext holds anything related to the EventHandler itself and presently only allows an EventHandler to unregister itself. Events \u00b6 Geyser has the following predefined Events. DownstreamPacketReceiveEvent \u00b6 cancellable Modifier and Type Method Description GeyserSession getSession() Gets the current session Packet getPacket() Gets the Packet Triggered for each packet received from downstream. If cancelled then regular processing of the packet will not occur. DownstreamPacketSendEvent \u00b6 cancellable Modifier and Type Method Description GeyserSession getSession() Gets the current session Packet getPacket() Gets the Packet Triggered for each packet sent to downstream. If cancelled then the packet will not be sent. GeyserStopEvent \u00b6 Triggered after Geyser has finished starting. GeyserStopEvent \u00b6 Triggered when Geyser is about to stop. PluginDisableEvent \u00b6 Modifier and Type Method Description GeyserPlugin getPlugin() Gets the Plugin Triggered each time a plugin is disabled. PluginEnableEvent \u00b6 cancellable Modifier and Type Method Description GeyserPlugin getPlugin() Gets the Plugin Triggered each time a plugin is enabled. PluginMessageEvent \u00b6 cancellable Modifier and Type Method Description String getChannel() Gets the message channel byte[] getData() Gets the message data GeyserSession getSession() Gets the current session UpstreamPacketReceiveEvent \u00b6 cancellable Modifier and Type Method Description GeyserSession getSession() Gets the current session BedrockPacket getPacket() Gets the Packet Triggered for each packet received from upstream. If cancelled then regular processing of the packet will not occur. UpstreamPacketSendEvent \u00b6 cancellable Modifier and Type Method Description GeyserSession getSession() Gets the current session BedrockPacket getPacket() Gets the Packet Triggered for each packet sent to upstream. If cancelled then the packet will not be sent.","title":"Events"},{"location":"events/#events","text":"Geyser has an Event Manager that allows one to listen to or trigger an event easily. Events can be easily defined either by defining a method to be an event handler or by providing a lambda. Each event handler will be executed in turn based upon their priority.","title":"Events"},{"location":"events/#triggering-an-event","text":"An event is derived from either GeyserEvent or CancellableGeyserEvent . Example public class MyCustomEvent extends GeyserEvent { } The event is triggered through the triggerEvent method of the Event Manager. Example eventManager . triggerEvent ( new MyCustomEvent ()); This returns an EventResult which can be used to chain additional commands based upon the result. They include ifNotCancelled and ifCancelled . Example eventManager . triggerEvent ( new MyCustomEvent ()) . ifNotCancelled (( result ) -> { // Code executed if events were not cancelled });","title":"Triggering an Event"},{"location":"events/#listening-to-an-event","text":"There are two ways to listen for an event. One can either create an event handler method or one can create an anonymous lamda to be executed when the event is triggered.","title":"Listening to an Event"},{"location":"events/#class-event-handler","text":"An event handler method is a method that is annotated with @Event . The class it belongs to must also be registered with the event manager. Example public class MyClass { @Event public void onEnable ( EventContext ctx , MyCustomEvent event ) { System . err . println ( \"Hello World\" ); } } ... GeyserConnecter . getInstance (). getEventManager . registerEvents ( new MyClass ()); Important Plugins should use the registerEvents method inherited from GeyserPlugin . The @Event annotation has the following optional parameters: priority - Integer from 0 - 100. Default 50 . Event Handlers are executed in order from lowest to highest priority. ignoreCancelled - Boolean. Default true . If true then if an event is cancelled the handler will not be executed. The EventContext will be discussed later. MyCustomEvent is the event defined previously.","title":"Class Event Handler"},{"location":"events/#anonymous-lambda","text":"An event can be hooked through the on method of the EventManager provided with an anonymous function. This allows code to be placed logically close to where it is related in the code instead of having to set up a separate class and method listeners. Example GeyserConnector . getInstance (). getEventManager (). on ( MyCustomEvent . class , ( ctx , event ) -> { System . err . println ( \"Hello World\" ); }); Important Plugins should use the on method inherited from GeyserPlugin . This method takes 2 optional parameters specifying the priority of the event and if the handler should ignore cancelled events. This returns an EventRegisterResult that allows one to chain a delay on, normally to used to cancel the handler. It is safe to cancel an already cancelled handler. Example GeyserConnector . getInstance (). getEventManager (). on ( MyCustomEvent . class , ( ctx , event ) -> { System . err . println ( \"If this doesn't trigger in 10 seconds it is cancelled\" ); ctx . unregister (); }). onDelay (( ctx ) -> { ctx . unregister (); }, 10 , TimeUnit . SECONDS );","title":"Anonymous Lambda"},{"location":"events/#event-context","text":"The event handler receives an EventContext in addition to the Event class. The EventContext holds anything related to the EventHandler itself and presently only allows an EventHandler to unregister itself.","title":"Event Context"},{"location":"events/#events_1","text":"Geyser has the following predefined Events.","title":"Events"},{"location":"events/#downstreampacketreceiveevent","text":"cancellable Modifier and Type Method Description GeyserSession getSession() Gets the current session Packet getPacket() Gets the Packet Triggered for each packet received from downstream. If cancelled then regular processing of the packet will not occur.","title":"DownstreamPacketReceiveEvent"},{"location":"events/#downstreampacketsendevent","text":"cancellable Modifier and Type Method Description GeyserSession getSession() Gets the current session Packet getPacket() Gets the Packet Triggered for each packet sent to downstream. If cancelled then the packet will not be sent.","title":"DownstreamPacketSendEvent"},{"location":"events/#geyserstopevent","text":"Triggered after Geyser has finished starting.","title":"GeyserStopEvent"},{"location":"events/#geyserstopevent_1","text":"Triggered when Geyser is about to stop.","title":"GeyserStopEvent"},{"location":"events/#plugindisableevent","text":"Modifier and Type Method Description GeyserPlugin getPlugin() Gets the Plugin Triggered each time a plugin is disabled.","title":"PluginDisableEvent"},{"location":"events/#pluginenableevent","text":"cancellable Modifier and Type Method Description GeyserPlugin getPlugin() Gets the Plugin Triggered each time a plugin is enabled.","title":"PluginEnableEvent"},{"location":"events/#pluginmessageevent","text":"cancellable Modifier and Type Method Description String getChannel() Gets the message channel byte[] getData() Gets the message data GeyserSession getSession() Gets the current session","title":"PluginMessageEvent"},{"location":"events/#upstreampacketreceiveevent","text":"cancellable Modifier and Type Method Description GeyserSession getSession() Gets the current session BedrockPacket getPacket() Gets the Packet Triggered for each packet received from upstream. If cancelled then regular processing of the packet will not occur.","title":"UpstreamPacketReceiveEvent"},{"location":"events/#upstreampacketsendevent","text":"cancellable Modifier and Type Method Description GeyserSession getSession() Gets the current session BedrockPacket getPacket() Gets the Packet Triggered for each packet sent to upstream. If cancelled then the packet will not be sent.","title":"UpstreamPacketSendEvent"},{"location":"plugins/","text":"Plugins \u00b6 Geyser provides support for third party plugins which can be placed into a plugins folder under the Geyser data folder. Plugins provide a way to extend the features of Geyser without needing to deal with the Geyser code. It is hoped that developers will be able to create plugins that would be of use to others. This page describes how to write a plugin. Maven \u00b6 Add the following to the relevant section of your pom.xml <repositories> <!-- Bundabrg's Repo --> <repository> <id> bundabrg-repo </id> <url> https://repo.worldguard.com.au/repository/maven-public </url> <releases> <enabled> true </enabled> </releases> <snapshots> <enabled> true </enabled> </snapshots> </repository> </repositories> <dependencies> <!-- Geyser --> <dependency> <groupId> org.geysermc </groupId> <artifactId> connector </artifactId> <version> 1.0-SNAPSHOT </version> <scope> provided </scope> </dependency> </dependencies> Info Plugin support is presently only available through a feature branch and thus there will be references to a third party maven repository that holds a build of this branch. This will change in the future. Example Plugin \u00b6 @Plugin ( name = \"ExamplePlugin\" , version = \"1.1.0-dev\" , authors = { \"bundabrg\" }, description = \"Provides an example plugin\" ) public class MyPlugin extends GeyserPlugin { public MyPlugin ( PluginManager pluginManager , PluginClassLoader pluginClassLoader ) { super ( pluginManager , pluginClassLoader ); } @Event public void onEnable ( EventContext ctx , PluginEnableEvent event ) { if ( event . getPlugin () == this ) { System . err . println ( \"I'm alive\" ); // Register another class with event handlers registerEvents ( new MyAdditionalClass ()); // Example of lambda event hook on ( PluginDisableEvent . class , ( ctx , event ) -> { if ( event . getPlugin () == MyPlugin . this ) { System . err . println ( \"I'm also dead\" ); } }, PRIORITY . HIGH ); } } @Event public void onDisable ( EventContext ctx , PluginDisableEvent event ) { if ( event . getPlugin () == this ) { System . err . println ( \"I'm dead\" ); } } } Plugin EntryPoint \u00b6 A plugin must at a minimum define a class that extends GeyserPlugin and be annotated with @Plugin . The annotation provides details about the plugin such as its version and author(s). The following fields are available for @Plugin : name - Name of the plugin. Used in the logs. version - Version of the plugin. authors - A list of authors description - A short description of the plugin global - Should the plugin make its classes available to other plugins (default: true) Plugin Events \u00b6 A plugin will generally hook into several events and provides its own event registration inherited from GeyserPlugin . A plugin class will look for any methods annotated with @Event and will treat them as Event Handlers, using reflection to determine which event is being trapped. In the previous example the plugin has trapped both the PluginEnableEvent and PluginDisableEvent . Please refer to events for more information about the event system. Note There is no need to register the plugin class for events as it will be registered by default. Note The plugin class itself provides many of the registration methods found in the Event Manager to track which events belong to the plugin. You should use the plugins own registration methods in preference to those in the Event Manger. This includes registerEvents and on . Plugin Messages \u00b6 A plugin can communicate with a plugin on the downstream server through the use of plugin message channels. More information about this can be found here . Sending a Plugin Message \u00b6 To send a plugin message use GeyserSession#sendPluginMessage. Example ByteArrayDataOutput out = ByteStreams . newDataOutput (); out . writeUTF ( \"Data1\" ); out . writeUTF ( \"Data2\" ); session . sendPluginMessage ( \"myplugin:channel\" , out . toByteArray ()); Receiving Plugin Messages \u00b6 To receive plugin messages you need to first register to recieve the message then listen for the PluginMessageEvent . Example GeyserConnector . getInstance (). registerPluginChannel ( \"myplugin:channelname\" ); ... @Event void public onPluginMessageEvent ( EventContext context , PluginMessageEvent event ) { if ( ! event . getChannel (). equals ( \"myplugin:channelname\" )) { return ; } ... }","title":"Plugins"},{"location":"plugins/#plugins","text":"Geyser provides support for third party plugins which can be placed into a plugins folder under the Geyser data folder. Plugins provide a way to extend the features of Geyser without needing to deal with the Geyser code. It is hoped that developers will be able to create plugins that would be of use to others. This page describes how to write a plugin.","title":"Plugins"},{"location":"plugins/#maven","text":"Add the following to the relevant section of your pom.xml <repositories> <!-- Bundabrg's Repo --> <repository> <id> bundabrg-repo </id> <url> https://repo.worldguard.com.au/repository/maven-public </url> <releases> <enabled> true </enabled> </releases> <snapshots> <enabled> true </enabled> </snapshots> </repository> </repositories> <dependencies> <!-- Geyser --> <dependency> <groupId> org.geysermc </groupId> <artifactId> connector </artifactId> <version> 1.0-SNAPSHOT </version> <scope> provided </scope> </dependency> </dependencies> Info Plugin support is presently only available through a feature branch and thus there will be references to a third party maven repository that holds a build of this branch. This will change in the future.","title":"Maven"},{"location":"plugins/#example-plugin","text":"@Plugin ( name = \"ExamplePlugin\" , version = \"1.1.0-dev\" , authors = { \"bundabrg\" }, description = \"Provides an example plugin\" ) public class MyPlugin extends GeyserPlugin { public MyPlugin ( PluginManager pluginManager , PluginClassLoader pluginClassLoader ) { super ( pluginManager , pluginClassLoader ); } @Event public void onEnable ( EventContext ctx , PluginEnableEvent event ) { if ( event . getPlugin () == this ) { System . err . println ( \"I'm alive\" ); // Register another class with event handlers registerEvents ( new MyAdditionalClass ()); // Example of lambda event hook on ( PluginDisableEvent . class , ( ctx , event ) -> { if ( event . getPlugin () == MyPlugin . this ) { System . err . println ( \"I'm also dead\" ); } }, PRIORITY . HIGH ); } } @Event public void onDisable ( EventContext ctx , PluginDisableEvent event ) { if ( event . getPlugin () == this ) { System . err . println ( \"I'm dead\" ); } } }","title":"Example Plugin"},{"location":"plugins/#plugin-entrypoint","text":"A plugin must at a minimum define a class that extends GeyserPlugin and be annotated with @Plugin . The annotation provides details about the plugin such as its version and author(s). The following fields are available for @Plugin : name - Name of the plugin. Used in the logs. version - Version of the plugin. authors - A list of authors description - A short description of the plugin global - Should the plugin make its classes available to other plugins (default: true)","title":"Plugin EntryPoint"},{"location":"plugins/#plugin-events","text":"A plugin will generally hook into several events and provides its own event registration inherited from GeyserPlugin . A plugin class will look for any methods annotated with @Event and will treat them as Event Handlers, using reflection to determine which event is being trapped. In the previous example the plugin has trapped both the PluginEnableEvent and PluginDisableEvent . Please refer to events for more information about the event system. Note There is no need to register the plugin class for events as it will be registered by default. Note The plugin class itself provides many of the registration methods found in the Event Manager to track which events belong to the plugin. You should use the plugins own registration methods in preference to those in the Event Manger. This includes registerEvents and on .","title":"Plugin Events"},{"location":"plugins/#plugin-messages","text":"A plugin can communicate with a plugin on the downstream server through the use of plugin message channels. More information about this can be found here .","title":"Plugin Messages"},{"location":"plugins/#sending-a-plugin-message","text":"To send a plugin message use GeyserSession#sendPluginMessage. Example ByteArrayDataOutput out = ByteStreams . newDataOutput (); out . writeUTF ( \"Data1\" ); out . writeUTF ( \"Data2\" ); session . sendPluginMessage ( \"myplugin:channel\" , out . toByteArray ());","title":"Sending a Plugin Message"},{"location":"plugins/#receiving-plugin-messages","text":"To receive plugin messages you need to first register to recieve the message then listen for the PluginMessageEvent . Example GeyserConnector . getInstance (). registerPluginChannel ( \"myplugin:channelname\" ); ... @Event void public onPluginMessageEvent ( EventContext context , PluginMessageEvent event ) { if ( ! event . getChannel (). equals ( \"myplugin:channelname\" )) { return ; } ... }","title":"Receiving Plugin Messages"}]}